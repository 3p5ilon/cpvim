snippet snips "all snippets"
/*
   snips
   cp
   read
   minimal
   for
   fastio
   vin
   vout
   all
   rall
   sortv
   sortvd
   prefix
   bs
   lb
   ub
   gcd
   lcm
   binpow
   modpow
   modinv
   grid
   dir4
   dir8
   bfs
   dfs
   minheap
   set
   mset
   map
   umap
 */
endsnippet



snippet cp "CP Template"
#ifdef ONPC
#define _GLIBCXX_DEBUG
#endif
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
typedef long double ld;

int solve() {
	$0
	return 0;
}

int32_t main() {
	ios::sync_with_stdio(0);
	cin.tie(0);

	int TET = 1e9;
	// cin >> TET;

	for (int i = 1; i <= TET; i++) {
		if (solve()) break;
#ifdef ONPC
		cout << "__________________________" << endl;
#endif
	}

#ifdef ONPC
	cerr << endl << "finished in "
	     << clock() * 1.0 / CLOCKS_PER_SEC
	     << " sec" << endl;
#endif
}
endsnippet



snippet read "read first variable"
${1:int} ${2:n};
if (!(cin >> $2)) {
	return 1;
}
$0
endsnippet



snippet minimal "minimalist begin"
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

int32_t main() {
	$0
}
endsnippet



snippet for "for loop"
for (int ${1:i} = 0; $1 < ${2:n}; $1++) {
	$0
}
endsnippet



snippet fastio "fast io"
ios::sync_with_stdio(false);
cin.tie(nullptr);
cout.tie(nullptr);
$0
endsnippet



snippet vin "vector input"
vector<${1:int}> ${2:v}(${3:n});
for (int i = 0; i < $3; i++) {
	cin >> $2[i];
}
$0
endsnippet



snippet vout "vector output"
for (auto &x : ${1:v}) {
	cout << x << " ";
}
cout << "\n";
$0
endsnippet



snippet all "all(v)"
${1:v}.begin(), ${1:v}.end()
endsnippet



snippet rall "rall(v)"
${1:v}.rbegin(), ${1:v}.rend()
endsnippet



snippet sortv "sort vector"
sort(${1:v}.begin(), ${1:v}.end());
$0
endsnippet



snippet sortvd "sort vector desc"
sort(${1:v}.rbegin(), ${1:v}.rend());
$0
endsnippet



snippet prefix "prefix sum"
vector<long long> pref(${1:n}+1, 0);
for (int i = 0; i < $1; i++) {
	pref[i+1] = pref[i] + ${2:arr}[i];
}
$0
endsnippet



snippet bs "binary search"
int l = 0, r = ${1:n}-1;
while (l <= r) {
	int mid = l + (r - l) / 2;
	if (${2:condition}) {
		r = mid - 1;
	} else {
		l = mid + 1;
	}
}
$0
endsnippet



snippet lb "lower_bound"
int pos = lower_bound(${1:v}.begin(), ${1:v}.end(), ${2:x}) - ${1:v}.begin();
$0
endsnippet



snippet ub "upper_bound"
int pos = upper_bound(${1:v}.begin(), ${1:v}.end(), ${2:x}) - ${1:v}.begin();
$0
endsnippet



snippet gcd "gcd"
ll g = __gcd(${1:a}, ${2:b});
$0
endsnippet



snippet lcm "lcm"
ll l = (${1:a} / __gcd($1, ${2:b})) * $2;
$0
endsnippet



snippet binpow "binary exponentiation"
long long binpow(long long a, long long b) {
	long long res = 1;
	while (b) {
		if (b & 1) res *= a;
		a *= a;
		b >>= 1;
	}
	return res;
}
$0
endsnippet



snippet modpow "modular exponentiation"
long long modpow(long long a, long long b, long long mod) {
	long long res = 1;
	a %= mod;
	while (b) {
		if (b & 1) res = (res * a) % mod;
		a = (a * a) % mod;
		b >>= 1;
	}
	return res;
}
$0
endsnippet



snippet modinv "mod inverse prime"
long long modinv(long long a, long long mod) {
	return modpow(a, mod - 2, mod);
}
$0
endsnippet



snippet grid "2D grid input"
vector<vector<int>> grid(${1:n}, vector<int>(${2:m}));
for (int i = 0; i < $1; i++) {
	for (int j = 0; j < $2; j++) {
		cin >> grid[i][j];
	}
}
$0
endsnippet



snippet dir4 "4 directions"
int dx[4] = {1, -1, 0, 0};
int dy[4] = {0, 0, 1, -1};
$0
endsnippet



snippet dir8 "8 directions"
int dx[8] = {1,-1,0,0,1,1,-1,-1};
int dy[8] = {0,0,1,-1,1,-1,1,-1};
$0
endsnippet



snippet bfs "BFS template"
queue<int> q;
vector<int> dist(${1:n}, -1);

q.push(${2:src});
dist[$2] = 0;

while (!q.empty()) {
	int u = q.front(); q.pop();
	for (auto v : ${3:adj}[u]) {
		if (dist[v] == -1) {
			dist[v] = dist[u] + 1;
			q.push(v);
		}
	}
}
$0
endsnippet



snippet dfs "DFS template"
void dfs(int u) {
	${1:vis}[u] = true;
	for (auto v : ${2:adj}[u]) {
		if (!${1:vis}[v]) {
			dfs(v);
		}
	}
}
$0
endsnippet



snippet minheap "min heap"
priority_queue<int, vector<int>, greater<int>> pq;
$0
endsnippet



snippet set "set"
set<int> s;
$0
endsnippet



snippet mset "multiset"
multiset<int> ms;
$0
endsnippet



snippet map "map"
map<int, int> mp;
$0
endsnippet



snippet umap "unordered_map"
unordered_map<int, int> mp;
$0
endsnippet